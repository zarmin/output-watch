#!/usr/bin/env python

import subprocess
import os
import sys
from threading import Thread
import datetime
import time


def print_usage():
  print("Invalid usage, usage: {} <timeout> process...".format(sys.argv[]))
  sys.exit(1)
 
process_args = sys.argv[2:]

if len(process_args) == 0:
  print_usage()

timeout = 0
try:
  timeout = int(sys.argv[1])
except ValueError:
  print("Timeout value must be a number {}".format(sys.argv[1]))
  print_usage()
  sys.exit(2)

if timeout <= 0:
  print("Timeout cannot be 0 or below")
  print_usage()
  sys.exit(2)

last_write_time = datetime.datetime.now()
proc = None

def output_watch():
  while True: 
    current_time = datetime.datetime.now()
    diff = abs((current_time - last_write_time).seconds)
    if diff > timeout:
      sys.stderr.write("No output for {} seconds... Exiting!\n".format(timeout))
      if proc != None:
        proc.kill()      
      os._exit(3)
      return
    time.sleep(2)

thread = Thread(target = output_watch)
thread.start()

try:
  proc = subprocess.Popen(process_args, stdout=subprocess.PIPE)
except OSError as e:
  print "ERROR ({0}): {1}".format(e.errno, e.strerror)
  sys.exit(e.errno)

while True:
  try:
    line = proc.stdout.readline()
    if line != '':
      last_write_time = datetime.datetime.now()
      os.write(1, line)
    else:
      break
  except KeyboardInterrupt:
    os._exit(130)

proc.wait()

os._exit(proc.returncode)

